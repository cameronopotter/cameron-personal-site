# Production Docker Compose configuration for Digital Greenhouse
# Optimized for production deployment with security, performance, and monitoring

version: '3.8'

services:
  # ===================================
  # Backend API Service
  # ===================================
  backend:
    image: ghcr.io/cameronopotter/digital-greenhouse/backend:latest
    container_name: digital-greenhouse-backend
    restart: unless-stopped
    
    environment:
      # Database
      - DATABASE_URL=${DATABASE_URL}
      - DB_POOL_SIZE=${DB_POOL_SIZE:-20}
      - DB_MAX_OVERFLOW=${DB_MAX_OVERFLOW:-30}
      
      # Redis
      - REDIS_URL=${REDIS_URL}
      - REDIS_POOL_SIZE=${REDIS_POOL_SIZE:-10}
      
      # Application
      - SECRET_KEY=${SECRET_KEY}
      - DEBUG=${DEBUG:-false}
      - ENVIRONMENT=${ENVIRONMENT:-production}
      
      # Security
      - ALLOWED_HOSTS=${ALLOWED_HOSTS:-digital-greenhouse.dev,api.digital-greenhouse.dev}
      - CORS_ORIGINS=${CORS_ORIGINS:-https://digital-greenhouse.dev}
      
      # External APIs
      - GITHUB_TOKEN=${GITHUB_TOKEN}
      - SPOTIFY_CLIENT_ID=${SPOTIFY_CLIENT_ID}
      - SPOTIFY_CLIENT_SECRET=${SPOTIFY_CLIENT_SECRET}
      - WAKATIME_API_KEY=${WAKATIME_API_KEY}
      - OPENWEATHER_API_KEY=${OPENWEATHER_API_KEY}
      
      # Monitoring
      - SENTRY_DSN=${SENTRY_DSN}
      - ENABLE_MONITORING=${ENABLE_MONITORING:-true}
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
      
      # Performance
      - WORKERS=${WORKERS:-4}
      - WORKER_CLASS=uvicorn.workers.UvicornWorker
      - MAX_REQUESTS=${MAX_REQUESTS:-1000}
      - MAX_REQUESTS_JITTER=${MAX_REQUESTS_JITTER:-100}
      - PRELOAD_APP=${PRELOAD_APP:-true}
      
      # Feature flags
      - ENABLE_AUTO_OPTIMIZATION=${ENABLE_AUTO_OPTIMIZATION:-true}
      - ENABLE_RATE_LIMITING=${ENABLE_RATE_LIMITING:-true}
      - ENABLE_CACHING=${ENABLE_CACHING:-true}
    
    ports:
      - "8000:8000"
    
    volumes:
      - backend_logs:/app/logs:rw
      - backend_tmp:/app/tmp:rw
    
    networks:
      - digital-greenhouse-network
    
    depends_on:
      - database
      - redis
    
    healthcheck:
      test: ["/usr/local/bin/healthcheck-backend.sh"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=backend"

  # ===================================
  # Frontend Service
  # ===================================
  frontend:
    image: ghcr.io/cameronopotter/digital-greenhouse/frontend:latest
    container_name: digital-greenhouse-frontend
    restart: unless-stopped
    
    environment:
      - NGINX_HOST=${NGINX_HOST:-digital-greenhouse.dev}
      - NGINX_PORT=${NGINX_PORT:-80}
      - BACKEND_URL=http://backend:8000
    
    ports:
      - "80:8080"
      - "443:8443"  # HTTPS if SSL is configured
    
    volumes:
      - nginx_logs:/var/log/nginx:rw
      - nginx_cache:/var/cache/nginx:rw
      # SSL certificates (if using HTTPS)
      # - ./ssl:/etc/nginx/ssl:ro
    
    networks:
      - digital-greenhouse-network
    
    depends_on:
      - backend
    
    healthcheck:
      test: ["/usr/local/bin/healthcheck.sh", "frontend"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M
    
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=frontend"

  # ===================================
  # Database Service
  # ===================================
  database:
    image: postgres:15-alpine
    container_name: digital-greenhouse-db
    restart: unless-stopped
    
    environment:
      - POSTGRES_DB=${POSTGRES_DB:-digital_greenhouse}
      - POSTGRES_USER=${POSTGRES_USER:-digital_greenhouse}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_INITDB_ARGS=--auth-host=scram-sha-256
      - POSTGRES_HOST_AUTH_METHOD=scram-sha-256
    
    ports:
      - "5432:5432"
    
    volumes:
      - postgres_data:/var/lib/postgresql/data:rw
      - postgres_backups:/backups:rw
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    
    networks:
      - digital-greenhouse-network
    
    command: >
      postgres
      -c max_connections=200
      -c shared_buffers=256MB
      -c effective_cache_size=1GB
      -c maintenance_work_mem=64MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=4MB
      -c min_wal_size=1GB
      -c max_wal_size=4GB
      -c max_worker_processes=8
      -c max_parallel_workers_per_gather=4
      -c max_parallel_workers=8
      -c max_parallel_maintenance_workers=4
      -c logging_collector=on
      -c log_destination=stderr
      -c log_statement=mod
      -c log_min_duration_statement=1000
    
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-digital_greenhouse} -d ${POSTGRES_DB:-digital_greenhouse}"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=database"

  # ===================================
  # Redis Cache Service
  # ===================================
  redis:
    image: redis:7-alpine
    container_name: digital-greenhouse-redis
    restart: unless-stopped
    
    command: >
      redis-server
      --appendonly yes
      --appendfsync everysec
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
      --tcp-keepalive 60
      --timeout 300
      --tcp-backlog 511
      --save 900 1
      --save 300 10
      --save 60 10000
    
    ports:
      - "6379:6379"
    
    volumes:
      - redis_data:/data:rw
    
    networks:
      - digital-greenhouse-network
    
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M
    
    logging:
      driver: json-file
      options:
        max-size: "5m"
        max-file: "3"
        labels: "service=redis"

  # ===================================
  # Background Task Worker
  # ===================================
  worker:
    image: ghcr.io/cameronopotter/digital-greenhouse/backend:latest
    container_name: digital-greenhouse-worker
    restart: unless-stopped
    
    command: ["celery", "-A", "app.tasks.celery_app", "worker", "--loglevel=info", "--concurrency=4"]
    
    environment:
      # Same as backend but optimized for worker
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - SECRET_KEY=${SECRET_KEY}
      - ENVIRONMENT=${ENVIRONMENT:-production}
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
      
      # Worker-specific settings
      - CELERY_WORKER_CONCURRENCY=${CELERY_WORKER_CONCURRENCY:-4}
      - CELERY_WORKER_PREFETCH_MULTIPLIER=${CELERY_WORKER_PREFETCH_MULTIPLIER:-1}
      
      # External APIs (for background tasks)
      - GITHUB_TOKEN=${GITHUB_TOKEN}
      - SPOTIFY_CLIENT_ID=${SPOTIFY_CLIENT_ID}
      - SPOTIFY_CLIENT_SECRET=${SPOTIFY_CLIENT_SECRET}
      - WAKATIME_API_KEY=${WAKATIME_API_KEY}
      - OPENWEATHER_API_KEY=${OPENWEATHER_API_KEY}
    
    volumes:
      - worker_logs:/app/logs:rw
    
    networks:
      - digital-greenhouse-network
    
    depends_on:
      - database
      - redis
    
    healthcheck:
      test: ["CMD-SHELL", "celery -A app.tasks.celery_app inspect ping"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 60s
    
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 256M
    
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=worker"

  # ===================================
  # Monitoring and Observability
  # ===================================
  
  # Prometheus for metrics collection
  prometheus:
    image: prom/prometheus:latest
    container_name: digital-greenhouse-prometheus
    restart: unless-stopped
    
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=30d'
      - '--web.enable-lifecycle'
    
    ports:
      - "9090:9090"
    
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus:rw
    
    networks:
      - digital-greenhouse-network
    
    depends_on:
      - backend
    
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M

  # Grafana for metrics visualization
  grafana:
    image: grafana/grafana:latest
    container_name: digital-greenhouse-grafana
    restart: unless-stopped
    
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_SERVER_ROOT_URL=https://monitoring.digital-greenhouse.dev
    
    ports:
      - "3001:3000"
    
    volumes:
      - grafana_data:/var/lib/grafana:rw
      - ./monitoring/grafana/dashboards:/var/lib/grafana/dashboards:ro
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning:ro
    
    networks:
      - digital-greenhouse-network
    
    depends_on:
      - prometheus
    
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M

  # ===================================
  # Reverse Proxy and Load Balancer
  # ===================================
  
  traefik:
    image: traefik:v3.0
    container_name: digital-greenhouse-traefik
    restart: unless-stopped
    
    command:
      - "--api.dashboard=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.letsencrypt.acme.tlschallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.email=${ACME_EMAIL}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      - "--metrics.prometheus=true"
      - "--log.level=INFO"
    
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"  # Traefik dashboard
    
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - letsencrypt_data:/letsencrypt:rw
    
    networks:
      - digital-greenhouse-network
    
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.traefik.rule=Host(`traefik.digital-greenhouse.dev`)"
      - "traefik.http.routers.traefik.entrypoints=websecure"
      - "traefik.http.routers.traefik.tls.certresolver=letsencrypt"
      - "traefik.http.routers.traefik.service=api@internal"

# ===================================
# Networks
# ===================================
networks:
  digital-greenhouse-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

# ===================================
# Persistent Volumes
# ===================================
volumes:
  # Database
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./data}/postgres
  
  postgres_backups:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./data}/backups
  
  # Cache
  redis_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./data}/redis
  
  # Logs
  backend_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${LOGS_PATH:-./logs}/backend
  
  worker_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${LOGS_PATH:-./logs}/worker
  
  nginx_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${LOGS_PATH:-./logs}/nginx
  
  nginx_cache:
    driver: local
  
  # Monitoring
  prometheus_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./data}/prometheus
  
  grafana_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./data}/grafana
  
  # SSL
  letsencrypt_data:
    driver: local